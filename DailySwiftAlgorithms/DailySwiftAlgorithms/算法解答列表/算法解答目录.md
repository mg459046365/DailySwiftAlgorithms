---
typora-root-url: ../算法解答列表
---

#  算法解答目录

1. [**20190701**](https://github.com/mg459046365/DailySwiftAlgorithms/blob/master/DailySwiftAlgorithms/DailySwiftAlgorithms/算法解答列表/20190701.swift)  实现一个栈，该栈带有出栈（pop）、入栈(push)、取最小元素（getMin）3个方法。保证这三个方法的时间复杂度都是O(1)。

2. [**20190702**](https://github.com/mg459046365/DailySwiftAlgorithms/blob/master/DailySwiftAlgorithms/DailySwiftAlgorithms/算法解答列表/20190702.swift)  写一段代码，求出两个整数的最大公约数，要尽量优化算法的性能。

3. [**20190704**](https://github.com/mg459046365/DailySwiftAlgorithms/blob/master/DailySwiftAlgorithms/DailySwiftAlgorithms/算法解答列表/20190704.swift)  实现一个方法，来判断一个正整数是否是2的整数次幂（如16是2的4次方，返回true；18不是2的整数次幂，返回false）。要求性能尽可能高。

4. [**20190705**](https://github.com/mg459046365/DailySwiftAlgorithms/blob/master/DailySwiftAlgorithms/DailySwiftAlgorithms/算法解答列表/20190705.swift)  有一个无序整型数组，如何求出该数组排序后的任意两个相邻元素的最大差值？要求时间和空间复杂度尽可能低。例：2 6 3 4 5 10 9，排序后2 3 4 5 6 9 10，最大相邻差值为3（9 - 6 = 3）。

5. [**使用栈实现队列**](https://github.com/mg459046365/DailySwiftAlgorithms/blob/master/DailySwiftAlgorithms/DailySwiftAlgorithms/队列/StackByQueue.swift) 

6. [**使用队列实现栈**](https://github.com/mg459046365/DailySwiftAlgorithms/blob/master/DailySwiftAlgorithms/DailySwiftAlgorithms/队列/StackByQueue.swift) 

7. [**201907024**](https://github.com/mg459046365/DailySwiftAlgorithms/blob/master/DailySwiftAlgorithms/DailySwiftAlgorithms/算法解答列表/20190724.swift)  给出一个正整数，找出这个正整数所有数字全排列的下一个数。

8. [**201907026**](https://github.com/mg459046365/DailySwiftAlgorithms/blob/master/DailySwiftAlgorithms/DailySwiftAlgorithms/算法解答列表/20190726.swift)  给出一个整数，从该整数中去掉K个数字，要求剩下的数字形成的新整数尽可能小。应该如何选取北被去掉的整数？其中整数的长度大于或等于K，给出的整数的大小可以超过long类型的数字范围。

   ​    

